#include <iostream>

using namespace std;

class AWOV
{
public:
    virtual ~AWOV() = 0; // 1
};

AWOV::~AWOV() {} // 2 : 이 정의부가 없다면, 링크에러가 발생한다.

/**

1번과 2번을 서로 연결하여 이해하기가 어렵다.
분명히 pure virtual function으로 선언한 후에,
다시 함수를 정의해 놓다니..
아래의 설명을 참조하면 이해가 되겠지?


>> 이해완료 : 가상 소멸자의 경우에는, vtbl을 사용하지 않고, 파생클래스의 소멸자가 기본클래스의 소멸자를 직접 호출함.
			  따라서, 함수의 본체가 반드시 필요하다.


## 요약하면, 가상 소멸자의 호출메커니즘은 vtbl을 통하지 않고, 파생클래스가 기본클래스의 소멸자를 직접 호출한다는 것이다.


C++에서 순수 가상 함수의 기계적 의미는 해당 추상 클래스의 vtbl에서 그 순수 가상 함수의 포인터가 0(=null)로 들어 있다는 것입니다.
즉, AWOV 클래스가 이렇게 되어 있다면,

class AWOV
{
public:
	virtual ~AWOV()=0;
	virtual foo();
};

이 클래스의 vtbl은 다음과 같이 나옵니다.

vptr -> [ 0           ]   // 첫째 : AWOV::~AWOV()의 주소
        [ &(AWOV::foo)]   // 둘째 : AWOV::foo()의 주소

하지만, 가상 소멸자의 호출 매커니즘은 파생 클래스의 소멸자가 기본 클래스의 그것을 직접 호출하도록 (컴파일러에 의해) 만들어집니다.
vtbl을 통하지 않는다는 것이죠. 따라서 AWOV::~AWOV의 본문이 정의되어 있지 않으면 링크 에러를 내게 됩니다.
이것은 "이렇게 해도 컴파일이 되네" 수준이 아니라 "꼭 이렇게 해야 합니다"라는 의무 조항입니다.

*/


class Impl : public AWOV
{

};


/////////////////////////////////////////////////////////////////////////////////////////////
class Foo
{
public:
    Foo() {}
    ~Foo() {}

private:
    int x,y,z;
};

class Bar
{
public:
    Bar() {}
    virtual ~Bar() {}
private:
    int x,y,z;
};


/// since C++11

class final_class final
{

};

class not_allowed : public final_class /// compile error : cannot derive from 'final' base ~
{

};

/////////////////////////////////////////////////////////////////////////////////////////////


int main()
{
    cout << "Hello world!" << endl;

    AWOV *ptr = new Impl;
    delete ptr;


    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// 핵심 :
    ///         C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때,
    ///         그 기본 클래스에 비가상 소멸자가 들어 있다면, 프로그램의 동작은 미정의 사항이다.
    ///         대부분 파생 클래스의 소멸자가 호출되지 않는다.
    ////////////////////////////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// 핵심 :
    ///         불필요한 상황에서 virtual을 사용하면 메모리 사용량이 증가한다.
    ///         따라서 필요한 경우에만 사용하자.
    ////////////////////////////////////////////////////////////////////////////////////////////////



    ////////////////////////////////////////////////////////////////////////////////////////////////
    /// 핵심 :
    ///         비가상 소멸자를 가진 클래스를 기본 클래스로 사용해서는 안된다.
    ///         Java / C# 등의 언어에는 이것을 막기 위한 매커니즘이 존재하지만, C++에는 존재하지 않는다.
    ///         final / sealed 등
    ///
    ///         수정 : C++11부터 아래처럼 final 키워드가 추가되었다.
    ///                 http://en.cppreference.com/w/cpp/language/final
    ////////////////////////////////////////////////////////////////////////////////////////////////



    /// vptr : 가상 함수 테이블 포인터         (가상함수테이블을 가르키고 있는 포인터)
    /// vtbl : 가상 함수 테이블              (클래스내 가상함수들의 포인터들이 모여있는 배열)

    /// vptr ->
    ///         [               <- 이 함수포인터의 배열을 vtbl이라 부른다.
    ///          fptr_a,
    ///          fptr_b,
    ///          fptr_c,
    ///          fptr_d,
    ///          ...
    ///         ]

    cout << "size of Foo : " << sizeof(Foo) << endl; /// 8
    cout << "size of Bar : " << sizeof(Bar) << endl; /// 16 : Foo() 대비 100% 증가. (8bytes = vtbl + pointer)

    return 0;
}
